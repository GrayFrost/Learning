# 垃圾回收

## 垃圾回收机制

### 标记清除

此算法把"对象是否不再需要"简化定义为"对象是否可以获得"。

假定有个根root对象，从根出发，找到所有从根开始的引用对象，再找这些对象的引用对象，一直往下找。然后垃圾回收器能找到所有可获得的对象和不可获得的对象，不可获得的对象将被清除。

看了网上的文章，我理解的流程大概是这样的：

首先给所有变量添加上标记，然后从根出发进行查找，对于那些能够到达的对象，即仍在被引用的对象，对这些对象进行标记清除。查找完后，那些仍然有标记的，就是无法到达的对象，说明已经没有被引用了。对这些仍有标记的变量进行清除。



### 引用计数

此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”.。如果没有引用指向该对象, 对象将被垃圾回收机制回收

记录每个值被引用的次数，当某个值的引用次数为 0 时，则说明没有办法再访问这个值了，因此就可以将其占用的内存空间回收。

有个很经典的问题是对象互相引用导致的循环引用问题。



## 内存泄漏

内存泄露就是不再被需要的内存, 由于某种原因, 无法被释放。

会出现内存泄漏的情况：

* 以外的全局变量

* 忘记清除定时器

* 闭包

* 忘记清除的dom引用