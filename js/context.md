# 执行上下文
执行上下文（Execution Context），当运行一段代码，js引擎会做一些为变量分配内存，代码上下关联的操作，EC可以理解为代码解析和执行的环境。

## 执行上下文的类型
执行上下文分为三种：
* `全局执行上下文`，一个程序中只有一个全局执行上下文
* `函数执行上下文`，调用函数时创建，能有多个
* `eval执行上下文`，在eval函数中执行的代码拥有的执行环境

## 执行上下文的生命周期

### 创建阶段
我在看文章的时候，发现文章之间的介绍是有出入的，后来看了大部分的文章之后，发现其实是js版本之间的差异，所以分开介绍。但总的方向是一样的，大概步骤为：
* 创建存储变量、函数、形参等的一个环境；
* 创建作用域链；
* 确定this的绑定。

#### ES3
ES3中的执行上下文中包括以下内容：
* `变量对象`，Variable Object。用来存放执行上下文中可被访问的函数、形参、变量声明、arguments对象等。并不能在js环境中访问。
* `活动对象`，Activation Object。被激活的VO。当进入一个执行上下文时，变量对象被激活，此时才能访问变量，函数等。
* `作用域链`，规定了如何查找变量，即确定当前执行代码对变量的访问权限。当函数创建时，其所在的作用域已确定。
* `this`，即调用者。


结构如下：
```
executionContext：{
    [variable object | activation object]：{
        arguments,
        variables: [...],
        funcions: [...]
    },
    scope chain: variable object + all parents scopes
    thisValue: context object
}

```

#### ES5
ES5规范中取出了ES3中的变量对象和活动对象，用词法环境（`LexicalEnvironment`）和变量环境（`VariableEnvironment`）来代替。  
* `词法环境组件`， 
* `变量环境组件`，也是一个词法环境。与词法环境的区别是，词法环境存let、const变量，变量环境存var变量
* `this`

结构如下：
```
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```
词法环境内部有两个组件：环境记录器、外部环境的引用。
* 环境记录器：存储变量和函数声明。
* 外部环境的引用：可以访问父级词法环境。

环境记录也有两种类型：声明性环境记录、对象环境记录。
* 声明性环境记录：存储变量、函数、参数。函数环境包含声明性环境记录
* 对象环境记录：用于定义在全局执行上下文中出现的变量和函数的关联。全局环境包含对象环境记录。


```
GlobalExectionContext = {  
  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: "Object",  
      // 标识符绑定在这里 
    outer: <null>  
  }  
}

FunctionExectionContext = {  
  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里 
    outer: <Global or outer function environment reference>  
  }  
}

```

我是不是可以理解为ES3中的变量对象活动对象对应这里的环境记录器，作用域链对应外部环境的引用。

#### 变量提升
在执行上下文的创建阶段，代码会被扫描并解析变量和函数。函数声明会被存放到环境中，var变量会被设置成undefined，let或const变量被设置成为初始化。
当遇到函数和变量同名且都被提升的情况下，函数声明优先级比较高。

### 执行阶段
变量赋值，函数引用，执行代码

### 回收阶段
执行上下文出栈等待回收执行上下文

## 总结
### ES3执行上下文总结
1. 函数代码被调用；
2. 创建执行上下文；
3. 进入创建阶段：
  1. 创建变量对象vo:
    1. 根据函数的参数，创建并初始化arguments对象；
    2.扫描函数内部的代码，查找函数声明，找到所有函数声明，将函数名和函数引用存入变量对象，如果vo中存在同名函数，覆盖；
    3. 扫描函数内部的代码，查找变量声明，找到所有变量声明，存入vo，并初始化为undefined人，如果vo中存在该变量名，跳过不会覆盖。
  2. 初始化作用域链
  3. 确定上下文中this的指向
4. 进入执行阶段：
  1. 解释运行代码，逐行执行代码，为变量赋值

### ES5执行上下文总结
因为全局和函数的环境记录区别，我们从完整的代码快来描述整个过程。
1. 程序代码运行，创建全局执行上下文
  1. 创建`词法环境`
    1. 创建`对象环境记录器`，用来定义出现在全局上下文中的变量和函数
    2. 创建`外部环境引用`，为null
  2. 创建`变量环境`
    1. 创建对象环境记录器，处理var定义的变量，初始值为undefined
    2. 创建外部环境引用，为null
  3. 确定`this`，为全局对象。
2. 调用函数，创建函数执行上下文
  1. 创建`词法环境`
    1. 创建`声明式环境记录器`。存储变量、函数和参数，arguments对象，函数参数长度length。处理let和const的变量
    2. 创建`外部环境引用`，值为全局对象或父级词法环境
  2. 创建`变量环境`
    1. 创建`生命是环境记录器`。存储变量、函数和参数，arguments对象，函数参数长度length。处理var的变量
    2. 创建`外部环境引用`，值为全局对象或父级词法环境
  3. 确定this




